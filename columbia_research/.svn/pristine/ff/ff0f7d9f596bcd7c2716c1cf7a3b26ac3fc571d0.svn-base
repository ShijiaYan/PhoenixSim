package edu.columbia.lrl.CrossLayer.physical_models.devices.demux.awg;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import ch.epfl.general_libraries.results.DataPoint;
import ch.epfl.general_libraries.results.Execution;
import ch.epfl.general_libraries.utils.MoreArrays;
import ch.epfl.general_libraries.utils.SimpleMap;
import ch.epfl.general_libraries.clazzes.ParamName;
import edu.columbia.lrl.CrossLayer.PowerConsumption;
import edu.columbia.lrl.CrossLayer.physical_models.PhysicalParameterAndModelsSet;
import edu.columbia.lrl.CrossLayer.physical_models.PowerPenalty;
import edu.columbia.lrl.CrossLayer.physical_models.devices.demux.AbstractDemux;
import edu.columbia.lrl.CrossLayer.physical_models.generic_models.xtalk.AbstractXtalkPPModel;
import edu.columbia.lrl.CrossLayer.physical_models.generic_models.xtalk.MeisamJLTXtalkModel;
import edu.columbia.lrl.CrossLayer.physical_models.util.AbstractLinkFormat;
import edu.columbia.lrl.CrossLayer.physical_models.util.Constants;

public class AwgDemux extends AbstractDemux {

	// parameters
	double passiveIL ;
	double polarizationLoss ;
	double demuxFSR ;
	double numBranch ;
	double awgStaticPower ;
	double Q_min = 1000 ;
	double Q_max = 5000 ;
	double steps ;
	boolean trackDetails ;
	private AbstractXtalkPPModel xtalkModel;

	public AwgDemux(
			@ParamName(name = "Xtalk model", defaultClass_=MeisamJLTXtalkModel.class) AbstractXtalkPPModel xtalkModel,			
			@ParamName(name = "Passive insertion loss (dB)", default_ = "5") double passiveIL,
			@ParamName(name = "Polarization loss (dB)", default_ = "0.5") double polarizationLoss,
			@ParamName(name = "Demux FSR (nm)", default_ = "20") double demuxFSR,
			@ParamName(name = "optimization steps", default_ = "100") int steps,
			@ParamName(name = "Number of Branches", default_ = "20") double numBranch,
			@ParamName(name = "AWG Thermal Tunning Power (mW)", default_ = "0") double awgStaticPower,
			@ParamName(name = "Track Details", default_ = "true") boolean trackDetails ) {
		this.passiveIL = passiveIL ;
		this.demuxFSR = demuxFSR ;
		this.numBranch = numBranch ;
		this.steps = steps ;
		this.trackDetails = trackDetails ;
		this.xtalkModel = xtalkModel;
	}

	@Override
	public Map<String, String> getAllParameters() {
		Map<String, String> map = new SimpleMap<String, String>();
		map.put("Passive insertion loss (dB)", passiveIL + "");
		map.put("Polarization Loss (dB)", polarizationLoss + "");
		map.put("AWG Demux FSR", demuxFSR + "");
		map.put("Number of Branches", numBranch + "");
		map.put("AWG Thermal Tunning Power", awgStaticPower + "");
		map.put("Xtalk model", xtalkModel.getClass().getSimpleName());
		map.putAll(xtalkModel.getAllParameters());
		return map;
	}


	public ArrayList<PowerPenalty> getPowerPenalties(
			PhysicalParameterAndModelsSet modelSet, 
			AbstractLinkFormat linkFormat, 
			Execution ex,
			double modulationER) {
		Constants ct = modelSet.getConstants();
		
		double channelSpacing = ct.wavelengthsToChannelSpacing(linkFormat.getNumberOfChannels());
		int wavelengths = linkFormat.getNumberOfChannels();
		double rate = linkFormat.getWavelengthRate();
		
		double dQ = (Q_max - Q_min) / steps;
		int size = (int) Math.ceil((Q_max - Q_min) / dQ);
		double[] Q_vec = new double[size];
		for (int i = 0; i < Q_vec.length; i++) {
			Q_vec[i] = Q_min + i * dQ;
		}
		double[] xtalk_pp1 = new double[size];
		double[] sum_pp = new double[size];
		double[] insertionLoss = new double[size] ;
		double[] truncationPP = new double[size] ;

		for (int i = 0; i < Q_vec.length; i++) {
			double Q_demux = Q_vec[i];

			double add_xtalk1 = 0;
			for (int j = (int) -Math.ceil(wavelengths / 2); j <= (int) Math.ceil(wavelengths / 2); j++) {
				if (j != 0) {

					add_xtalk1 += getXtalkPower(Q_demux, ct.getCenterFrequency(), j*channelSpacing) ;
				}
			}
			
			xtalk_pp1[i] = xtalkModel.getXtalkPP(add_xtalk1, modelSet.getTargetBER(), modulationER);
			
		//	xtalk_pp1[i] = -5 * Math.log10(1 - 6 * add_xtalk1) ;  // for BER = 10 ^ (-9)
			
			double pp_trunc = getTruncationPenalty(Q_demux, ct.getCenterFrequency(), rate) ;
			
			
			insertionLoss[i] = passiveIL + polarizationLoss ;
			truncationPP[i] = pp_trunc ;
					
			sum_pp[i] = xtalk_pp1[i] + pp_trunc + insertionLoss[i] ;
		}

		double min = Double.MAX_VALUE;
		int bestIndex = 0;
		for (int i = 0; i < sum_pp.length; i++) {
			if (sum_pp[i] < min) {
				min = sum_pp[i];
				bestIndex = i;
			}
		}
		

		
		PowerPenalty xtalk = new PowerPenalty(PowerPenalty.CROSSTALK, DEMUX, xtalk_pp1[bestIndex]);
		PowerPenalty trunc = new PowerPenalty(PowerPenalty.TRUNCATION, DEMUX, truncationPP[bestIndex]);
		PowerPenalty il = new PowerPenalty(PowerPenalty.INSERTIONLOSS, DEMUX, insertionLoss[bestIndex]);
		
		
		DataPoint basic = new DataPoint();
		basic.addProperty("wavelengths", wavelengths);
		basic.addProperties(this.getAllParameters());
		basic.addProperty("Filter array model", this.getClass().getSimpleName());
		
		if (ex != null && trackDetails) {
			
			DataPoint dp1 = basic.getDerivedDataPoint();
			dp1.addResultProperty("ideal filter PP", min);
			dp1.addResultProperty("ideal filter Q", Q_vec[bestIndex]);
			
			ex.addDataPoint(dp1);
			
			for (int i = 0; i < sum_pp.length; i++) {
				DataPoint dp = basic.getDerivedDataPoint();
				if (xtalk_pp1[i] == Double.NaN || truncationPP[i] == Double.NaN) {
					continue;
				}
				dp.addProperty("Q value", Q_vec[i]);
				dp.addResultProperty("Xtalk Penalty(Q)", xtalk_pp1[i]);
				dp.addResultProperty("Total Filter Penalty(Q)", sum_pp[i]);
				dp.addResultProperty("Insertion Loss(Q)", insertionLoss[i]);
				dp.addResultProperty("Truncation Penalty(Q)", truncationPP[i]);
				dp.addResultProperty("Data Rate (Gb/s)", linkFormat.getWavelengthRate()/1e9);
				ex.addDataPoint(dp);
			}
		}

		return MoreArrays.getArrayList(xtalk, trunc, il);
	}
	
	
	
	
	public double getAwgTransmission(double freq, double centerFreq, double Q_demux ){
		double bandwidth = centerFreq/Q_demux ;
		double arg = Math.sin(Math.PI * 2*(freq-centerFreq)/bandwidth)/(Math.PI * 2*(freq-centerFreq)/bandwidth ) ;
		double trans = Math.pow(arg, 2) ;
		return trans ;
	}
	
	public double getTruncationPenalty (double Q_demux, double centerFreq, double rate){
		double bandwidth = centerFreq/Q_demux ;
		double alpha = bandwidth/rate ;
		double A = Math.abs(alpha-2) ;
		double B = Math.abs(alpha+2) ;
		double penalty = 1/(24*alpha) *(-2*Math.pow(alpha, 3)-16+ Math.pow(A, 3)+Math.pow(B, 3)) ;
		double penaltyDB = -5*Math.log10(penalty) ;
		return penaltyDB ;
	}
	
	public double getXtalkPower(double Q_demux, double centerFreq, double channelSpacing){
		double freq = centerFreq + channelSpacing ;
		double xtalk = getAwgTransmission(freq, centerFreq, Q_demux ) ;
		return xtalk ;
	}
	
	
	// Overriding the abstract power consumption in the super class
	@Override
	public List<PowerConsumption> getDevicePowerConsumptions(
			PhysicalParameterAndModelsSet modelSet, AbstractLinkFormat linkFormat) {
		ArrayList<PowerConsumption> pc = new ArrayList<PowerConsumption>(1);
		if (awgStaticPower != 0) {
			throw new IllegalStateException("Not implemented yet");	
		} else {
			return pc;
		}
	}

	@Override
	public boolean hasThroughCapability() {
		return false;
	}

	@Override
	public ArrayList<PowerPenalty> getPassbyPowerPenalties(PhysicalParameterAndModelsSet modelSet, AbstractLinkFormat linkFormat) {
		throw new IllegalStateException("Cannot be passedby");
	}	

}
