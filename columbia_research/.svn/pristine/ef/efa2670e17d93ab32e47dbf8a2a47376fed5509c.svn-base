package edu.columbia.lrl.CrossLayer.physical_models.devices.modulations.ook_nrz;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Map;
import java.util.TreeMap;

import ch.epfl.general_libraries.clazzes.ParamName;
import ch.epfl.general_libraries.experiment_aut.WrongExperimentException;
import ch.epfl.general_libraries.results.AbstractResultsManager;
import ch.epfl.general_libraries.results.DataPoint;
import ch.epfl.general_libraries.results.Execution;
import ch.epfl.general_libraries.results.PropertyMap;
import ch.epfl.general_libraries.utils.MoreArrays;
import ch.epfl.general_libraries.utils.TypeParser;
import ch.epfl.javancox.results_manager.SmartDataPointCollector;
import ch.epfl.javancox.results_manager.gui.DefaultResultDisplayingGUI;
import edu.columbia.lrl.CrossLayer.PowerConsumption;
import edu.columbia.lrl.CrossLayer.physical_models.PhysicalParameterAndModelsSet;
import edu.columbia.lrl.CrossLayer.physical_models.PowerPenalty;
import edu.columbia.lrl.CrossLayer.physical_models.devices.modulations.AbstractDemodulatorAndReceiver;
import edu.columbia.lrl.CrossLayer.physical_models.devices.modulations.Abstract_OOK_SERDES_PowerModel;
import edu.columbia.lrl.CrossLayer.physical_models.devices.modulations.OOK_SERDES_PowerModel;
import edu.columbia.lrl.CrossLayer.physical_models.util.AbstractLinkFormat;

public class OOK_NRZ_Receiver_RobertPolster extends Abstract_OOK_NRZ_Receiver {
	
//	private static final String fileName28 = "../columbia_research/data/cross_layer/receiver_power/DataS28PrecVsBRVsIin.csv";
//	private static final String fileName65 = "../columbia_research/data/cross_layer/receiver_power/DataS65PrecVsBRVsIin.csv";
	
	private static final String fileName28 = "/cross_layer/receiver_power/DataS28PrecVsBRVsIin.csv";
	private static final String fileName65 = "/cross_layer/receiver_power/DataS65PrecVsBRVsIin.csv";
	
	private TreeMap<Float, TreeMap<Float, Float>> db = new TreeMap<Float, TreeMap<Float, Float>>();
	
	private double responsivity;		
	private double polarizationLoss ;
	private Techno techno;
	
	public static enum Techno {
		_28nm,
		_65nm
	}
	
	public OOK_NRZ_Receiver_RobertPolster (Techno t, 
			@ParamName(name="Responsivity (A/W)", default_="1") double responsivity,
			@ParamName(name = "Polarization loss (dB)", default_ = "0.5") double polarizationLoss,
			@ParamName(name="SERDES model") Abstract_OOK_SERDES_PowerModel serdes
			) {
		super(0,serdes); // no jitter penalty -- accounted for
		this.responsivity = responsivity;
		this.polarizationLoss = polarizationLoss;	
		this.techno = t;
		switch (t) {
		case _28nm:
			parseFile(fileName28, this, null);
			break;
		case _65nm:
			parseFile(fileName65, this, null);
			break;
		
		}
	}
	
	@Override
	public Map<String, String> getAllReceiverParameters() {
		PropertyMap m = new PropertyMap();
		m.put("Polarization loss", polarizationLoss);
		m.put("Responsivity", responsivity);
		m.put("Receiver techno", techno.toString());
		return m;
	}	
	

	@Override
	public ArrayList<PowerConsumption> getDemodulationAndReceptionPowerConsumptions(
			double opticalPowerAtReceiverdBm,
			PhysicalParameterAndModelsSet modelSet,
			AbstractLinkFormat linkFormat) {
		ArrayList<PowerConsumption> superPowerCons = super.getDemodulationAndReceptionPowerConsumptions(opticalPowerAtReceiverdBm, modelSet, linkFormat);
		double inputCurrent = opticalPowerdBmToCurrent_A(opticalPowerAtReceiverdBm);
		double powCon = getPowerConsumptionMW(linkFormat.getWavelengthRate(), inputCurrent);
		PowerConsumption pc = new PowerConsumption("Receiver", false, false, true, powCon);
		superPowerCons.add(pc);
		return superPowerCons;
	}

	@Override
	public double getReceiverSensitivity(PhysicalParameterAndModelsSet modeSet,
			AbstractLinkFormat format) {
		double bitrate = format.getWavelengthRate();
		for (Map.Entry<Float, TreeMap<Float, Float>> ent : db.entrySet()) {
			double maxBitRateOfCurrent = ent.getValue().lastKey();
			if (maxBitRateOfCurrent > bitrate) {
				// means this current supports bitrate
				// as current are taking increasing order, it is the minimal sensitivity
				// we just have to convert it to dBm
				double optPow = currentToOpticalPowerdBm(ent.getKey()*1e6);
				return optPow;
			}
		}
		throw new WrongExperimentException("Bit rate beyond receiver capabilities");
	}

	
	
	@Override
	public ArrayList<PowerPenalty> getDemodulationPowerPenalties(
			PhysicalParameterAndModelsSet modelSet, AbstractLinkFormat linkFormat) {
		PowerPenalty pola = new PowerPenalty("Polarization loss", AbstractDemodulatorAndReceiver.RECEIVER, polarizationLoss);
		return MoreArrays.getArrayList(pola);
	}	
	
	private static void parseFile(String filename, OOK_NRZ_Receiver_RobertPolster db, AbstractResultsManager man) {
		Execution exec = new Execution();
		try {
//			BufferedReader br = new BufferedReader(new FileReader(filename));
			
			InputStream input = OOK_NRZ_Receiver_RobertPolster.class.getResourceAsStream(filename);
			BufferedReader br = new BufferedReader(new InputStreamReader(input, "UTF-8"));
			
			String line = "";
			while ((line = br.readLine()) != null) {
				String[] bits = line.split(",");
				String[] first = bits[0].split("/");
				float f = Float.parseFloat(first[0])/Float.parseFloat(first[1]);
				float s = Float.parseFloat(bits[1]);
				float t = Float.parseFloat(bits[2]);
				if (man != null) {
					DataPoint dp = new DataPoint();
					dp.addProperty("current", f);
					dp.addProperty("bitrate", s);
					dp.addResultProperty("power pJ/bit", t*1e12);
					if (Double.isNaN(t)) {
						System.out.println(".");
					}
					if (Double.isInfinite(t)) {
						System.out.println(".");						
					}
					exec.addDataPoint(dp);
				} 
				if (db != null) {
					if (Double.isNaN(t)) {
						System.out.println(".");
					}
					if (!Double.isInfinite(t)) {
						db.insert(f, s, t);					
					}			
				}
			}
		} catch (IOException e) {
			throw new IllegalStateException(e);
		}
		
		if (man != null) {
			man.addExecution(exec);
		}
		
	}

	private void insert(float f, float s, float t) {
		TreeMap<Float, Float> forF = db.get(f);
		if (forF == null) {
			forF = new TreeMap<Float, Float>();
			db.put(f, forF);
		}
		forF.put(s,  t);
	}
	
	public double getPowerConsumptionMW(double bitrate, double iCurrent) {
		
		float inputCurrent = (float)iCurrent;
		
		Map.Entry<Float, TreeMap<Float, Float>> bottomCurrent = db.floorEntry(inputCurrent);
		Map.Entry<Float, TreeMap<Float, Float>> topCurrent = db.higherEntry(inputCurrent);
		if (bottomCurrent == null) {
			throw new WrongExperimentException("Current too low");
		}
		if (topCurrent == null) {
			System.out.println("Warning: current too high");
			topCurrent = bottomCurrent;
		}
		
		Map.Entry<Float, Float> bottomCurrentBottomBitrate = bottomCurrent.getValue().floorEntry((float)bitrate);
		Map.Entry<Float, Float> bottomCurrentTopBitrate = bottomCurrent.getValue().higherEntry((float)bitrate);
		Map.Entry<Float, Float> topCurrentBottomBitrate = topCurrent.getValue().floorEntry((float)bitrate);
		Map.Entry<Float, Float> topCurrentTopBitrate = topCurrent.getValue().higherEntry((float)bitrate);
		
		if (bottomCurrentBottomBitrate == null) {
			// this one should never be true
		//	throw new IllegalStateException("Should not get there 1");
			bottomCurrentBottomBitrate = bottomCurrentTopBitrate;
			System.out.println("Warning: bitrate " 
			          + bitrate + " too low for correct receiver power estimation (using value for " 
					  + bottomCurrentTopBitrate.getKey() + ")");
		}
		if (bottomCurrentTopBitrate == null) {
			throw new WrongExperimentException("Too high bitrate for current");
		//	bottomCurrentTopBitrate = bottomCurrentBottomBitrate;
		//	System.out.println("Warning: bitrate too high for correct receiver power estimation");
		}
		if (topCurrentBottomBitrate == null) {
			topCurrentBottomBitrate = topCurrentTopBitrate;
			System.out.println("Warning: current potentially too high for bitrate");
		}
		if (topCurrentTopBitrate == null) {
			throw new IllegalStateException("Should not get there");
		//	topCurrentTopBitrate = topCurrentBottomBitrate;
		//	System.out.println("Warning: bitrate too high for correct receiver power estimation");			
		}
		
 		
		float x1 = bottomCurrent.getKey();
		float x2 = topCurrent.getKey();
		
		float x = inputCurrent;
		float fx;
		if (x1 != x2) {
			fx = (inputCurrent-x1)/(x2-x1);
		} else {
			fx = 0;
		}

		
		float y1 = bottomCurrentBottomBitrate.getKey();
		float y2 = topCurrentBottomBitrate.getKey();
		float y3 = bottomCurrentTopBitrate.getKey();
		float y4 = topCurrentTopBitrate.getKey();
		
		float z1 = bottomCurrentBottomBitrate.getValue();
		float z2 = topCurrentBottomBitrate.getValue();
		float z3 = bottomCurrentTopBitrate.getValue();
		float z4 = topCurrentTopBitrate.getValue();
		
		float fy1, fy2;
		
		if (y3 != y1) {
			fy1 = ((float)bitrate - y1)/(y3-y1);
		} else {
			fy1 = 0;
		}
		
		if (y4 != y2) {
			fy2 = ((float)bitrate - y2)/(y4-y2);
		} else {
			fy2 = 0;
		}
		
		float fza = z1 + fy1 * (z3-z1);
		float fzb = z2 + fy2 * (z4-z2);
		
		float finalZ = fza + fx*(fzb-fza);
		
		return finalZ*bitrate*1000;
	}
	
	private double currentToOpticalPowerdBm(double currentMicroA) {
		return 10*Math.log10((currentMicroA/responsivity)*1e-3);
	}
	
	private double opticalPowerdBmToCurrent_A(double dBm) {
		return Math.pow(10, dBm/10)*responsivity*1e-3;
	}
	
	public static void main(String[] args) {
		// testing
		test1();
	//	test65nm();
	}
	
	public static void test1() {
		
		SmartDataPointCollector col = new SmartDataPointCollector();
		
		Execution e = new Execution();
		
		
	//	for (Techno t: new Techno[]{Techno._65nm}) {
		for (Techno t : Techno.values()) {
			DataPoint d = new DataPoint();
			d.addProperty("Techno", t.toString());
			OOK_NRZ_Receiver_RobertPolster rec = new OOK_NRZ_Receiver_RobertPolster(t,1, 0.5, new OOK_SERDES_PowerModel());
		//	for (Double bitRateInGbs : new double[]{1d, 10d, 20, 30}) {
			for (Double bitRateInGbs : TypeParser.parseDouble("1:40lin200")) {
			//	for (Float currentMicroA : TypeParser.parseFloat("20:24lin5")) {
				for (Float currentMicroA : TypeParser.parseFloat("1:250log500")) {
					try {
						
						DataPoint dp = d.getDerivedDataPoint();
						
						
						double pow = rec.getPowerConsumptionMW(bitRateInGbs*1e9, currentMicroA*1e-6f);
						
					
						dp.addProperty("input optical power (uW)", currentMicroA/rec.responsivity);
						dp.addProperty("input optical power (dBm)", rec.currentToOpticalPowerdBm(currentMicroA));
					
						dp.addProperty("current (uA)", currentMicroA);
						dp.addProperty("bitrate (gbs)", bitRateInGbs);
						dp.addResultProperty("power", pow);
					
						e.addDataPoint(dp);
					}
					catch (Exception ex) {
						System.out.println(ex.getMessage());
					}
				}
			}
		}
		
		col.addExecution(e);
		
		DefaultResultDisplayingGUI.displayDefault(col);
	}
	
	public static void test65nm() {
		SmartDataPointCollector col = new SmartDataPointCollector();
		
		parseFile(fileName65, null, col);
		
		
		DefaultResultDisplayingGUI.displayDefault(col);
	}
}
