package edu.columbia.lrl.CrossLayer.physical_models.devices.switches;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.apache.commons.math.complex.Complex;

import ch.epfl.general_libraries.utils.MoreArrays;
import ch.epfl.general_libraries.utils.Pair;
import ch.epfl.general_libraries.utils.SimpleMap;
import ch.epfl.general_libraries.clazzes.ParamName;
import edu.columbia.lrl.CrossLayer.PowerConsumption;
import edu.columbia.lrl.CrossLayer.physical_models.PhysicalParameterAndModelsSet;
import edu.columbia.lrl.CrossLayer.physical_models.PowerPenalty;
import edu.columbia.lrl.CrossLayer.physical_models.devices.demux.ring_array.truncation.Abstract_SincSquare_Lorentzian_TruncationModel;
import edu.columbia.lrl.CrossLayer.physical_models.devices.demux.ring_array.truncation.PolynomBased_SincSquare_Lorentzian_TruncationModel;
import edu.columbia.lrl.CrossLayer.physical_models.util.AbstractLinkFormat;
import edu.columbia.lrl.CrossLayer.physical_models.util.Constants;


public class Switch1x2 extends AbstractRingBasedSwitch {

	double lossCoefficient;
	boolean trackDetails;
	
	Abstract_SincSquare_Lorentzian_TruncationModel truncationPowerPenalty;
	
	public Switch1x2(
			@ParamName(name="Loss coefficient", default_="4") double lossCoefficient,
			@ParamName(name="Track details", default_="false") boolean trackDetails,
			@ParamName(name = "Switch ring driving power (mW)", default_ = DEFAULT_DRIVING_POWER_MW) double switchRingDrivingPower,
			@ParamName(name = "Truncation model to use", defaultClass_ = PolynomBased_SincSquare_Lorentzian_TruncationModel.class) Abstract_SincSquare_Lorentzian_TruncationModel truncModel			
			) {
		super(switchRingDrivingPower);
		this.lossCoefficient = lossCoefficient;
		this.trackDetails = trackDetails;
		
		this.truncationPowerPenalty = truncModel;
	}
	
	@Override
	public Map<String, String> getAllParameters() {
		return SimpleMap.getMap("Loss coefficient", lossCoefficient+"",
								"Truncation model at 1x2 switch", truncationPowerPenalty.getClass().getSimpleName());	
	}

	
	@Override
	public List<PowerConsumption> getDevicePowerConsumptions(
			PhysicalParameterAndModelsSet modelSet, AbstractLinkFormat linkFormat) {
		ArrayList<PowerConsumption> pc = new ArrayList<PowerConsumption>(1);
		PowerConsumption p = new PowerConsumption("1x2 Switches", false, false, false, modelSet.getDefaultSingleRingTTPowerMW() + (0.5*drivingPower));
		pc.add(p);
		return pc;
	}		
	
	public ArrayList<PowerPenalty> getPowerPenalties(
			Constants ct, 
			AbstractLinkFormat linkFormat, 
			int numberDrop, 
			int numberThrough) {
		
		int wavelengths = linkFormat.getNumberOfChannels();
		double rate = linkFormat.getWavelengthRate();

		double c0 = ct.getSpeedOfLight();
		double neff = ct.getEffectiveIndex();
		double lambda0 = ct.getCenterWavelength();
		
		double channelSpacing = ct.wavelengthsToChannelSpacing(wavelengths);
		
		double radius = c0/(2*Math.PI*neff*channelSpacing);
		double L = 2*Math.PI*radius;
		
		double fsr_wavelength = Math.pow(lambda0,2d)/(neff*L);
		double fsr_freq = (c0/ Math.pow(lambda0,2d))*fsr_wavelength;
		
		double shift;
		if (fsr_freq < 500e9)
			shift = fsr_freq/2;
		else
			shift = 250e9;
			
		double ring_loss_dB = 2*Math.PI*radius*lossCoefficient*100;
		double alpha1 = Math.sqrt(Math.pow(10, -ring_loss_dB/10));		// <------ check alpha1 = alpha ?
		double half_alpha = Math.sqrt(Math.pow(10, -(ring_loss_dB/2)/10)); // <--- alpha almost equal to half-alpha ?
		
		double delta_alpha = getLossFromInjection(ct.getCenterFrequency(), shift, ct.getEffectiveIndex());
		double alpha_with_carriers = alpha1*Math.exp(-delta_alpha*L);
		double half_alpha_with_carriers = half_alpha*Math.exp(-delta_alpha*L);
		
		int numSamples = 500;
		
		double[] t_vec = new double[numSamples];
		for (int i = 0 ; i < t_vec.length ; i++) {
			t_vec[i] = 0.5 + (i*(.5/numSamples));
		}
		
		double[] total_loss_vec = new double[numSamples];
		double[] through_IL_vec = new double[numSamples];
		double[] drop_IL_vec = new double[numSamples];
		double[] FWHM_freq_vec = new double[numSamples];
		double[] pp_trunc_vec = new double[numSamples];
		
		int numPhaseSamples = 629*2;
		double[] phase_vec = new double[numPhaseSamples];
		for (int i = 0 ; i < phase_vec.length ; i++) {
			phase_vec[i] = i*(Math.PI/numPhaseSamples);
		}
		int iterations = t_vec.length;
		for (int i = 0 ; i < iterations ; i++) {
			double through_power = getThroughIL(t_vec[i], alpha1, phase_vec[0], shift, 1, channelSpacing);
			through_IL_vec[i] = 10*Math.log10(through_power);
			
			double drop_power = getDropIL(t_vec[i], alpha_with_carriers, half_alpha_with_carriers, phase_vec[0]); 
			drop_IL_vec[i] = 10*Math.log10(drop_power);
			
			double[] drop_port_response = new double[phase_vec.length];
			for (int j = 0 ; j < phase_vec.length ; j++) {
				drop_power = getDropIL(t_vec[i], alpha_with_carriers, half_alpha_with_carriers, phase_vec[j]);
				drop_port_response[j] = drop_power;
			}
			
			double max_drop = MoreArrays.max(drop_port_response);
			double[] normalized_drop_port = MoreArrays.product(drop_port_response, 1/max_drop);
			
			int half_ind = 0;
			double half_val = 0;
			
			for (int j = 0 ; j < normalized_drop_port.length ; j++) {
				if (normalized_drop_port[j] < .5) {
					half_ind = j;
					half_val = normalized_drop_port[j];
					break;
				}
			}
			
			//TODO: figure out how to handle this correctly
			if( half_ind == 0 )
				break;
			
			double distance_minus = Math.abs(0.5-half_val);
			double distance_plus = Math.abs(0.5-normalized_drop_port[half_ind-1]);
			if (distance_plus < distance_minus) {
				half_ind = half_ind-1;
			}
			
			double FWHM_radian = phase_vec[half_ind]*2;
			FWHM_freq_vec[i] = (FWHM_radian/(2*Math.PI))*fsr_freq;
					
			double switchQ = ct.getCenterFrequency()/FWHM_freq_vec[i];
			double pp_trunc = truncationPowerPenalty.getPowerPenalty(ct, rate, switchQ);
			pp_trunc_vec[i] = pp_trunc;
			
			total_loss_vec[i] = (numberDrop*(-drop_IL_vec[i]))+(numberThrough*(-through_IL_vec[i])) + pp_trunc;
		}
				
		Pair<Double, Integer> min_indexP = MoreArrays.minAndIndex(total_loss_vec);
		int min_index = min_indexP.getSecond();
		

	/*	if( Constants.getRecordResults() && trackDetails ) {
			MultiResult switchLosses = new MultiResult("1x2 Switch losses");
			
			switchLosses.simpleResult("through loss", -through_IL_vec[min_index]);
			switchLosses.simpleResult("drop loss", -drop_IL_vec[min_index]);
			switchLosses.simpleResult("power penalty", pp_trunc_vec[min_index]);
			switchLosses.simpleResult("Total loss", total_loss_vec[min_index]);
			
			resultManager.add(switchLosses);
		}*/
		
		
		//min_index can be -1 if all loss is infinity
		if( min_index >= 0 ) {
			PowerPenalty through = new PowerPenalty("1x2 switch through","switch", -through_IL_vec[min_index]).multiply(numberThrough);
			PowerPenalty drop = new PowerPenalty("1x2 switch drop","switch", -drop_IL_vec[min_index]).multiply(numberDrop);
			PowerPenalty trunc = new PowerPenalty("1x2 switch trunc","switch", pp_trunc_vec[min_index]);
			
			return MoreArrays.getArrayList(through, drop, trunc);
		}
		
		return MoreArrays.getArrayList(new PowerPenalty("1x2 switch","switch", Double.MAX_VALUE)); //infinity
	}
	
	private double getLossFromInjection(double v0, double resonanceShift, double effectiveIndex) {

		double dn_eff = -effectiveIndex/v0*resonanceShift;
		
		double[] x = new double[10000];
		double[] y = new double[x.length];
		for (int i = 0 ; i < x.length ; i++) {
			x[i] = (i+1)*1e15;
			y[i] = dn_eff + 8.8e-22*x[i] + 8.5e-18*Math.pow(x[i], 0.8); // <----------- ?!?!?!   power 0.8 ??
		}
		
		int greater_inds = -1;
		int smaller_inds = Integer.MAX_VALUE;
		for (int i = 0 ; i < x.length ; i++) {		
			if (y[i] > 0 && greater_inds == -1) {
				greater_inds = i;
			}
			if (y[i] < 0) {
				smaller_inds = i;
			}
		}
		
		double[] x_refined = new double[1000];
		double diff = ((x[greater_inds] - x[smaller_inds]) / (double)(x_refined.length));

		for (int i = 0 ; i < x_refined.length ; i++) {
			x_refined[i] = x[smaller_inds] + (i*diff);
		}
		double[] y_refined = new double[x_refined.length];
		for (int i = 0 ; i < y_refined.length ; i++) {
			y_refined[i] = dn_eff + 8.8e-22*x_refined[i] + 8.5e-18*Math.pow(x_refined[i], 0.8);
		}
		int biggerIn = -1;
		for (int i = 0 ; i < y_refined.length ; i++) {
			if (y_refined[i] < 0) {
				biggerIn = i;
			}
		}
		
		
		double dN = x_refined[biggerIn];
		
		return 8.5e-18*dN + 6e-18*dN;
	}

	private double getThroughIL(double t, double alpha, double phase, double shift, int do_shift, double channelSpacing) {
		Complex one = new Complex(1, 0);		
		Complex alphaC = new Complex(alpha, 0);
		Complex tC = new Complex(t, 0);
		Complex t2C = new Complex(t*t, 0);
		
		Complex et1;
		if (do_shift == 1) {
			double theta = (shift/channelSpacing)* 2 * Math.PI + phase;


			Complex thetaI = new Complex(0, theta);
			Complex expThetaI = thetaI.exp();			
			Complex alphaExpThetaI = expThetaI.multiply(alphaC);			
			et1 = one.subtract(alphaExpThetaI).multiply(tC).divide(
				one.subtract(t2C.multiply(alphaExpThetaI))
			);
		} else {
			Complex phaseI = new Complex(0, phase);
			Complex expPhaseI = phaseI.exp();
			Complex alphaExpPhaseI = expPhaseI.multiply(alphaC);
			et1 = one.subtract(alphaExpPhaseI).multiply(tC).divide(
				one.subtract(t2C.multiply(alphaExpPhaseI))
			);
		}
		return Math.pow(et1.abs(), 2);
	}
	
	private double getDropIL(double t, double alpha, double half_alpha, double phase) {
		
		Complex one = new Complex(1, 0);

		double minusK2 = -(1-Math.pow(t,2));
		Complex a = new Complex(minusK2*half_alpha, 0);
		
		Complex b = new Complex(Math.pow(t,2)*alpha, 0);

		Complex phaseI = new Complex(0, phase);
		Complex expPhaseI = phaseI.exp();
		
		Complex et2 = a.multiply(expPhaseI).divide(
			one.subtract(b.multiply(expPhaseI))
		);
		return Math.pow(et2.abs(),2);
	}


}
